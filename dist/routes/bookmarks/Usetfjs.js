/* src/routes/bookmarks/Usetfjs.svelte generated by Svelte v3.31.1 */
import {
	SvelteComponent,
	append,
	attr,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	set_data,
	set_style,
	space,
	text,
	transition_in,
	transition_out
} from "../../../web_modules/svelte/internal.js";

import useWorker from "../../background/use-worker.js";
import { onMount, onDestroy, createEventDispatcher } from "../../../web_modules/svelte.js";
import { BookIcon, CpuIcon } from "../../../web_modules/svelte-feather-icons.js";

function create_fragment(ctx) {
	let div2;
	let span;
	let t0_value = folder.title + "";
	let t0;
	let t1;
	let button;
	let bookicon;
	let t2;
	let div1;
	let div0;
	let current;
	let mounted;
	let dispose;
	bookicon = new BookIcon({ props: { size: "1x" } });

	return {
		c() {
			div2 = element("div");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			button = element("button");
			create_component(bookicon.$$.fragment);
			t2 = space();
			div1 = element("div");
			div0 = element("div");
			attr(span, "class", "");
			attr(button, "class", "px-1");
			set_style(div0, "width", (/*progress*/ ctx[1] * 100 / /*examples*/ ctx[0].length).toFixed(3) + "%");
			attr(div0, "class", "shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-pink-500");
			attr(div1, "class", "shadow overflow-hidden w-full h-2 text-xs flex rounded bg-pink-200");
			attr(div2, "class", "flex w-full items-center content-center h-full");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, span);
			append(span, t0);
			append(div2, t1);
			append(div2, button);
			mount_component(bookicon, button, null);
			append(div2, t2);
			append(div2, div1);
			append(div1, div0);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*sendTraining*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*folder*/ 0) && t0_value !== (t0_value = folder.title + "")) set_data(t0, t0_value);

			if (!current || dirty & /*progress, examples*/ 3) {
				set_style(div0, "width", (/*progress*/ ctx[1] * 100 / /*examples*/ ctx[0].length).toFixed(3) + "%");
			}
		},
		i(local) {
			if (current) return;
			transition_in(bookicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(bookicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(bookicon);
			mounted = false;
			dispose();
		}
	};
}

const _useWorker = new Worker("dist/background/use-worker.js", { type: "module" });
let folder;
let folderId;
let regex = /[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~·•—–]/g;

function nameFolder(cache) {
	console.log("nameFolder", cache);

	// {title, classification}
	let cacheList = Object.entries(cache);

	let folderNames = cacheList.filter(([id, tree]) => tree.title && tree.children && tree.parent.id == folderId).map(([id, tree]) => ({
		title: tree.title,
		classification: tree.id + "_" + tree.title
	}));

	console.log("folderNames", folderNames.length, folderNames);
	let examples = folderNames.filter(td => td.classification && td.title);
	return examples;
}

function tagsJoined(cache) {
	console.log("firstTrainer", cache);

	// {title, classification}
	let cacheList = Object.entries(cache);

	// train with name folder
	// (c > 3 ? ' '+ t : '' )
	let tagsJoin = cacheList.filter(([id, tree]) => tree.title && tree.children && tree.tags.length && tree.parent.id == folderId).map(([id, tree]) => ({
		title: tree.tags.reduce((a, [t, c]) => a += ` ${t}`, ""),
		classification: tree.id + "_" + tree.title
	}));

	console.log("tagsJoin", tagsJoin.length, tagsJoin);
	let examples = tagsJoin.filter(td => td.classification && td.title);
	return examples;
}

function mainTags(cache) {
	console.log("mainTags", cache);

	// {title, classification}
	let cacheList = Object.entries(cache);

	// train with 2 first tags folder - and 1 children tags
	let tags2 = cacheList.filter(([id, tree]) => tree.title && tree.children && tree.tags.length && tree.parent.id == folderId).map(([id, tree]) => tree.tags.slice(0, 1).map(([t, c]) => ({
		title: t,
		classification: tree.id + "_" + tree.title
	}))).flat();

	console.log("tags2", tags2.length, tags2);
	let examples = [...tags2]; // ...tags2, ...link3
	examples = examples.filter(td => td.classification && td.title);
	return examples;
}

function mainLinks(cache) {
	console.log("mainLinks", cache);

	// {title, classification}
	let cacheList = Object.entries(cache);

	// select 2 links peer folder
	let link3 = cacheList.filter(([id, tree]) => tree.title && tree.children && tree.parent.id == folderId).map(([id, tree]) => tree.children.filter(n => n.url && n.parent).slice(0, 3)).flat().map(tree => ({
		title: tree.title + " " + tree.url,
		classification: tree.parent.id + "_" + tree.parent.title
	}));

	console.log("link3", link3.length, link3);
	return link3.filter(td => td.classification && td.title);
}

function sendAnalisys(data) {
	if (!data.length) return;
	window.dispatchEvent(new CustomEvent("worker.analisys", { detail: data }));
}

function instance($$self, $$props, $$invalidate) {
	let { overview } = $$props;
	let { cache } = $$props;
	let { data = [] } = $$props;
	let examples;
	let progress = 0;

	let trainers = [
		() => nameFolder(cache),
		() => tagsJoined(cache),
		() => mainTags(cache),
		() => mainLinks(cache)
	];

	function sendTraining() {
		if (trainers.length) {
			$$invalidate(0, examples = trainers[0]());
			examples.map(e => e.title = e.title.replace(regex, " "));
			trainers.shift();
			sendAnalisys(examples);
		}
	}

	const embedded = ({ detail }) => {
		$$invalidate(1, progress += detail.length);
		window.dispatchEvent(new CustomEvent("worker.classify", { detail }));
	};

	onMount(() => {
		window.addEventListener("worker.embedded", embedded);
	}); // setInterval(async() => {
	//   let randomLink = adaptedData.splice( Math.floor(Math.random() * adaptedData.length ),1)
	//   console.log('randomLink',randomLink);
	//     sendAnalisys([...randomLink])

	// }, 10000)
	onDestroy(async () => {
		console.log("onDestroy");
		window.removeEventListener("worker.embedded", embedded);
		_useWorker.terminate();
	});

	$$self.$$set = $$props => {
		if ("overview" in $$props) $$invalidate(4, overview = $$props.overview);
		if ("cache" in $$props) $$invalidate(5, cache = $$props.cache);
		if ("data" in $$props) $$invalidate(3, data = $$props.data);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*folder, overview*/ 16) {
			$: if (!folder) {
				console.log("folder??", folder);
				folder = overview;
				folderId = folder.id == "0" || folder.id == "1" ? "2" : folder.id;
			}
		}

		if ($$self.$$.dirty & /*cache, examples*/ 33) {
			$: if (cache && !examples) sendTraining();
		}

		if ($$self.$$.dirty & /*progress, data*/ 10) {
			$: if (progress > 0 && data && data.length) {
				console.log("sendAnalisys", data);
				sendAnalisys(data);
				$$invalidate(3, data = []);
			}
		}
	};

	return [examples, progress, sendTraining, data, overview, cache];
}

class Usetfjs extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { overview: 4, cache: 5, data: 3 });
	}
}

export default Usetfjs;