/* src/routes/folders/TreeView.svelte generated by Svelte v3.31.1 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	set_store_value,
	space,
	text,
	transition_in,
	transition_out
} from "../../../web_modules/svelte/internal.js";

import { onMount, createEventDispatcher } from "../../../web_modules/svelte.js";

import {
	AwardIcon,
	FolderMinusIcon,
	FolderPlusIcon,
	FolderIcon
} from "../../../web_modules/svelte-feather-icons.js";

import InlineInput from "../../../web_modules/svelte-inline-input.js";
import { filter, focused, overview } from "../../stores.js";
import chromeApi from "../../background/chrome-api.js";
import FolderAction from "./FolderAction.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[34] = list;
	child_ctx[35] = i;
	return child_ctx;
}

// (171:2) {#if !filterTerms.length || filterTerms.some(ft => title?.toLowerCase()?.includes(ft)) }
function create_if_block_1(ctx) {
	let span4;
	let span2;
	let span0;
	let current_block_type_index;
	let if_block0;
	let t0;
	let span1;
	let inlineinput;
	let updating_value;
	let t1;
	let t2;
	let t3;
	let span3;
	let folderaction;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_4, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*folders*/ ctx[7].length) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function inlineinput_value_binding(value) {
		/*inlineinput_value_binding*/ ctx[19].call(null, value);
	}

	let inlineinput_props = {
		labelClasses: "truncate",
		inputClasses: "bg-gray-200 wrap",
		placeholder: "bookmarks"
	};

	if (/*editableTitle*/ ctx[2] !== void 0) {
		inlineinput_props.value = /*editableTitle*/ ctx[2];
	}

	inlineinput = new InlineInput({ props: inlineinput_props });
	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));
	/*inlineinput_binding*/ ctx[20](inlineinput);
	let if_block1 = /*links*/ ctx[6] && create_if_block_3(ctx);
	let if_block2 = /*filterTerms*/ ctx[3].length && create_if_block_2(ctx);
	folderaction = new FolderAction({ props: { id: /*id*/ ctx[0] } });
	folderaction.$on("toggleFocus", /*toggleFocus*/ ctx[10]);
	folderaction.$on("overviewit", /*overviewit*/ ctx[12]);
	folderaction.$on("openOverride", /*openOverride*/ ctx[13]);
	folderaction.$on("openBookmark", /*openBookmark*/ ctx[14]);

	return {
		c() {
			span4 = element("span");
			span2 = element("span");
			span0 = element("span");
			if_block0.c();
			t0 = space();
			span1 = element("span");
			create_component(inlineinput.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			span3 = element("span");
			create_component(folderaction.$$.fragment);
			attr(span0, "class", "items-center");
			attr(span1, "class", "cursor-pointer rounded-md truncate pl-1");
			attr(span2, "class", "flex pointer cursor-pointer transition-transform items-center ");
			attr(span3, "class", "cursor-pointer absolute right-0 group-hover:bg-gray-300 p-1 rounded-md");
			attr(span4, "class", "flex group hover:bg-gray-200 justify-between items-center relative");
		},
		m(target, anchor) {
			insert(target, span4, anchor);
			append(span4, span2);
			append(span2, span0);
			if_blocks[current_block_type_index].m(span0, null);
			append(span2, t0);
			append(span2, span1);
			mount_component(inlineinput, span1, null);
			append(span2, t1);
			if (if_block1) if_block1.m(span2, null);
			append(span2, t2);
			if (if_block2) if_block2.m(span2, null);
			append(span4, t3);
			append(span4, span3);
			mount_component(folderaction, span3, null);
			current = true;

			if (!mounted) {
				dispose = listen(span0, "click", /*toggleExpansion*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(span0, null);
			}

			const inlineinput_changes = {};

			if (!updating_value && dirty[0] & /*editableTitle*/ 4) {
				updating_value = true;
				inlineinput_changes.value = /*editableTitle*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			inlineinput.$set(inlineinput_changes);

			if (/*links*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(span2, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*filterTerms*/ ctx[3].length) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					if_block2.m(span2, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			const folderaction_changes = {};
			if (dirty[0] & /*id*/ 1) folderaction_changes.id = /*id*/ ctx[0];
			folderaction.$set(folderaction_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(inlineinput.$$.fragment, local);
			transition_in(folderaction.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(inlineinput.$$.fragment, local);
			transition_out(folderaction.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span4);
			if_blocks[current_block_type_index].d();
			/*inlineinput_binding*/ ctx[20](null);
			destroy_component(inlineinput);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_component(folderaction);
			mounted = false;
			dispose();
		}
	};
}

// (178:5) {:else}
function create_else_block_1(ctx) {
	let foldericon;
	let current;
	foldericon = new FolderIcon({ props: { size: "1x" } });

	return {
		c() {
			create_component(foldericon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(foldericon, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(foldericon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(foldericon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(foldericon, detaching);
		}
	};
}

// (176:5) {#if folders.length }
function create_if_block_4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*expanded*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (177:50) {:else}
function create_else_block(ctx) {
	let folderplusicon;
	let current;
	folderplusicon = new FolderPlusIcon({ props: { size: "1x" } });

	return {
		c() {
			create_component(folderplusicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(folderplusicon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(folderplusicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folderplusicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(folderplusicon, detaching);
		}
	};
}

// (177:6) {#if expanded}
function create_if_block_5(ctx) {
	let folderminusicon;
	let current;
	folderminusicon = new FolderMinusIcon({ props: { size: "1x" } });

	return {
		c() {
			create_component(folderminusicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(folderminusicon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(folderminusicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folderminusicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(folderminusicon, detaching);
		}
	};
}

// (185:4) {#if links}
function create_if_block_3(ctx) {
	let span;
	let t0;
	let t1_value = /*links*/ ctx[6].length + "";
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text("[");
			t1 = text(t1_value);
			t2 = text("]");
			attr(span, "class", "text-xs text-gray-400");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*links*/ 64 && t1_value !== (t1_value = /*links*/ ctx[6].length + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (189:4) {#if filterTerms.length}
function create_if_block_2(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*path*/ ctx[5]);
			attr(span, "class", "text-xs text-gray-400 px-1");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*path*/ 32) set_data(t, /*path*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (201:2) {#if expanded || filterTerms.length }
function create_if_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*folders*/ ctx[7];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*folders, forward*/ 2176) {
				each_value = /*folders*/ ctx[7];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (202:3) {#each folders as child}
function create_each_block(ctx) {
	let treeview;
	let updating_tree;
	let current;

	function treeview_tree_binding(value) {
		/*treeview_tree_binding*/ ctx[21].call(null, value, /*child*/ ctx[33], /*each_value*/ ctx[34], /*child_index*/ ctx[35]);
	}

	let treeview_props = {};

	if (/*child*/ ctx[33] !== void 0) {
		treeview_props.tree = /*child*/ ctx[33];
	}

	treeview = new TreeView({ props: treeview_props });
	binding_callbacks.push(() => bind(treeview, "tree", treeview_tree_binding));
	treeview.$on("dirty", /*forward*/ ctx[11]);

	return {
		c() {
			create_component(treeview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(treeview, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const treeview_changes = {};

			if (!updating_tree && dirty[0] & /*folders*/ 128) {
				updating_tree = true;
				treeview_changes.tree = /*child*/ ctx[33];
				add_flush_callback(() => updating_tree = false);
			}

			treeview.$set(treeview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(treeview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(treeview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(treeview, detaching);
		}
	};
}

function create_fragment(ctx) {
	let ul;
	let li;
	let show_if = !/*filterTerms*/ ctx[3].length || /*filterTerms*/ ctx[3].some(/*func*/ ctx[18]);
	let t;
	let ul_class_value;
	let current;
	let if_block0 = show_if && create_if_block_1(ctx);
	let if_block1 = (/*expanded*/ ctx[8] || /*filterTerms*/ ctx[3].length) && create_if_block(ctx);

	return {
		c() {
			ul = element("ul");
			li = element("li");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(li, "class", "m-0 p-0 truncate");
			attr(ul, "class", ul_class_value = "m-0 style-none " + (/*filterTerms*/ ctx[3].length ? "" : "pl-2") + " select-none w-full");
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			append(ul, li);
			if (if_block0) if_block0.m(li, null);
			append(li, t);
			if (if_block1) if_block1.m(li, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*filterTerms, title*/ 10) show_if = !/*filterTerms*/ ctx[3].length || /*filterTerms*/ ctx[3].some(/*func*/ ctx[18]);

			if (show_if) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*filterTerms, title*/ 10) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(li, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*expanded*/ ctx[8] || /*filterTerms*/ ctx[3].length) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*expanded, filterTerms*/ 264) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*filterTerms*/ 8 && ul_class_value !== (ul_class_value = "m-0 style-none " + (/*filterTerms*/ ctx[3].length ? "" : "pl-2") + " select-none w-full")) {
				attr(ul, "class", ul_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

const _expansionState = {}; /* treeNodeId: expanded <boolean> */
const _focusState = {}; /* treeNodeId: expanded <boolean> */

function instance($$self, $$props, $$invalidate) {
	let $filter;
	let $focused;
	let $overview;
	component_subscribe($$self, filter, $$value => $$invalidate(17, $filter = $$value));
	component_subscribe($$self, focused, $$value => $$invalidate(24, $focused = $$value));
	component_subscribe($$self, overview, $$value => $$invalidate(25, $overview = $$value));
	const dispatch = createEventDispatcher();
	let { tree = { children: [] } } = $$props;
	let { id, title, url, children, parentId } = tree;
	let filterTerms = [];
	let el;
	let editableTitle;
	let path = "";

	const update = async newTitle => {
		if (title.startsWith("_BF-")) return;

		if (!!newTitle && !!id) {
			console.log(id, newTitle);
			let result = await chromeApi.bookmarks.update(id, { title: newTitle });
			console.log(result);
		} //dispatch('dirty');
	};

	let links = [], folders = [];
	let expanded;

	const toggleExpansion = () => {
		$$invalidate(8, expanded = _expansionState[title] = !expanded);
	};

	const toggleFocus = event => {
		event.stopPropagation();
		focus(tree);
	};

	onMount(async () => {
		$$invalidate(5, path = await chromeApi.extras.getPath(id));
	});

	const focus = async newfocus => {
		if (newfocus.id < 4) return;
		let bookmarkBar = (await chromeApi.bookmarks.get("1"))[0];

		if ($focused) {
			await removeFocus($focused, bookmarkBar);
			if (newfocus.id === $focused.id) return;
		}

		// $focused = { title: newfocus.title, id: newfocus.id }
		try {
			let result = await chromeApi.bookmarks.update(newfocus.id, { title: `_BF-${newfocus.title}` });
			let swapResult = await chromeApi.extras.swapChildren(newfocus, bookmarkBar);
			focused.set({ title: newfocus.title, id: newfocus.id });
		} catch(e) {
			console.log("swap or rename error", e);
		}

		dispatch("dirty");
	};

	const removeFocus = async (focused, bookmarkBar) => {
		await chromeApi.extras.swapChildren(focused, bookmarkBar);

		let result = await chromeApi.bookmarks.update(focused.id, {
			title: `${focused.title.replace("_BF-", "")}`
		});

		dispatch("dirty");
	};

	function forward() {
		// console.log("forward", tree);		
		$$invalidate(15, tree);

		dispatch("dirty");
	}

	const overviewit = async () => {
		set_store_value(overview, $overview = tree, $overview);
		console.log($overview);
	};

	let addLink = async link => {
		if (!link.id) {
			let nn = await chromeApi.bookmarks.create({
				"parentId": "" + id,
				"title": link.title,
				"url": link.url
			});

			dispatch("dirty");
		}
	};

	let removeLink = async link => {
		if (link.id) {
			await chromeApi.bookmarks.remove(link.id);
			dispatch("dirty");
		}
	};

	const openOverride = () => {
		chromeApi.tabs.createTab(`chrome://newtab?folderId=${id}&title=${title}`);
	};

	const openBookmark = () => {
		chromeApi.tabs.createTab(`chrome://bookmarks?id=${id}`);
	};

	async function createFolder() {
		let parentId = id || "1";
		let title = "new folder";
		let result = await chromeApi.bookmarks.create({ parentId, title });
		$$invalidate(16, children = [...children, result]);
		!expanded && toggleExpansion();
		dispatch("dirty");
	}

	const func = ft => title?.toLowerCase()?.includes(ft);

	function inlineinput_value_binding(value) {
		editableTitle = value;
		(($$invalidate(2, editableTitle), $$invalidate(1, title)), $$invalidate(15, tree));
	}

	function inlineinput_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(4, el);
		});
	}

	function treeview_tree_binding(value, child, each_value, child_index) {
		each_value[child_index] = value;
		(($$invalidate(7, folders), $$invalidate(16, children)), $$invalidate(15, tree));
	}

	$$self.$$set = $$props => {
		if ("tree" in $$props) $$invalidate(15, tree = $$props.tree);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$filter*/ 131072) {
			$: $$invalidate(3, filterTerms = $filter.split(" ").filter(t => (/^\/\w{2}/).test(t)).map(ft => ft.substring(1)));
		}

		if ($$self.$$.dirty[0] & /*tree*/ 32768) {
			$: if (tree) {
				($$invalidate(0, id = tree.id), $$invalidate(1, title = tree.title), url = tree.url, $$invalidate(16, children = tree.children));
				parentId = tree.parentId;
			}
		}

		if ($$self.$$.dirty[0] & /*title*/ 2) {
			$: $$invalidate(2, editableTitle = title && title.replace("_BF-", ""));
		}

		if ($$self.$$.dirty[0] & /*editableTitle, title*/ 6) {
			$: if (editableTitle) {
				if (editableTitle !== title) update(editableTitle);
			}
		}

		if ($$self.$$.dirty[0] & /*children*/ 65536) {
			$: if (children) {
				$$invalidate(6, links = children.filter(c => c.url));
				$$invalidate(7, folders = children.filter(c => !c.url));
			}
		}

		if ($$self.$$.dirty[0] & /*title, id*/ 3) {
			$: $$invalidate(8, expanded = _expansionState[title] || id < 3 || false);
		}
	};

	return [
		id,
		title,
		editableTitle,
		filterTerms,
		el,
		path,
		links,
		folders,
		expanded,
		toggleExpansion,
		toggleFocus,
		forward,
		overviewit,
		openOverride,
		openBookmark,
		tree,
		children,
		$filter,
		func,
		inlineinput_value_binding,
		inlineinput_binding,
		treeview_tree_binding
	];
}

class TreeView extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { tree: 15 }, [-1, -1]);
	}
}

export default TreeView;