/* src/routes/BookmarkFile.svelte generated by Svelte v3.31.1 */
import {
	SvelteComponent,
	append,
	component_subscribe,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_data,
	set_store_value,
	space,
	text,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import Dropzone from "../../web_modules/svelte-file-dropzone.js";
import statsApi from "../background/stats.js";
import { bookmarks, stats } from "../stores.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (100:2) {#each files.accepted as item}
function create_each_block(ctx) {
	let li;
	let t_value = /*item*/ ctx[5].name + "";
	let t;

	return {
		c() {
			li = element("li");
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 1 && t_value !== (t_value = /*item*/ ctx[5].name + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

function create_fragment(ctx) {
	let dropzone;
	let t;
	let ol;
	let current;
	dropzone = new Dropzone({});
	dropzone.$on("drop", /*handleFilesSelect*/ ctx[1]);
	let each_value = /*files*/ ctx[0].accepted;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			create_component(dropzone.$$.fragment);
			t = space();
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
		},
		m(target, anchor) {
			mount_component(dropzone, target, anchor);
			insert(target, t, anchor);
			insert(target, ol, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*files*/ 1) {
				each_value = /*files*/ ctx[0].accepted;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(dropzone.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dropzone.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dropzone, detaching);
			if (detaching) detach(t);
			if (detaching) detach(ol);
			destroy_each(each_blocks, detaching);
		}
	};
}

function xml2json(element, json) {
	var treeObject = {};
	let parser, docNode;

	// If string convert to document Node
	if (typeof element === "string") {
		if (window.DOMParser) {
			parser = new DOMParser();
			docNode = parser.parseFromString(element, "text/html");
		} else {
			// Microsoft strikes again
			docNode = new ActiveXObject("Microsoft.XMLDOM");

			docNode.async = false;
			docNode.loadXML(element);
		}

		element = docNode.children[0]; // firstChild;
	}

	let treeHTML = function (element) {
		let tags = [...element.children].reduce((a, n, i) => (a[n.nodeName] = a[n.nodeName] ? [...a[n.nodeName], n] : n) && a, {});
		let { TITLE, H1, H3, DL, DT, A } = tags;

		if (A) {
			let attrs = Object.values(A.attributes).reduce((a, n, i) => (a[n.nodeName] = n) && a, {});
			let { href, add_date, icon } = attrs;

			let link = {
				title: A.textContent,
				url: href && href.value,
				icon: icon && icon.value,
				dateAdded: add_date && add_date.value
			};

			return link;
		}

		
		let node = { title: (TITLE || H1 || H3)?.textContent };

		if (DL) {
			let P = DL; // .children[0];
			let children = [...P.children].map(c => treeHTML(c, node));
			node.children = children;
		}

		return node;
	};

	treeObject = treeHTML(element.children[1]);
	console.log("treeObject", treeObject);
	return json ? JSON.stringify(treeObject) : treeObject;
}

function instance($$self, $$props, $$invalidate) {
	let $stats;
	let $bookmarks;
	component_subscribe($$self, stats, $$value => $$invalidate(2, $stats = $$value));
	component_subscribe($$self, bookmarks, $$value => $$invalidate(3, $bookmarks = $$value));
	console.log("que pasa");
	let files = { accepted: [], rejected: [] };

	function handleFilesSelect(e) {
		const { acceptedFiles, fileRejections } = e.detail;
		$$invalidate(0, files.accepted = [...files.accepted, ...acceptedFiles], files);
		viewFile(files.accepted[0]);
	} // files.rejected = [...files.rejected, ...fileRejections];

	function viewFile(file) {
		console.log("file", file);

		if (file.name.match(/\.(html|xml|json)$/)) {
			var reader = new FileReader();

			reader.onload = function () {
				let content = reader.result.replace(/<p>/g, ""); // .replace(/<DT>/g, '')
				console.log("content", content);
				let result = xml2json(content, false); // stringify(json)
				console.log("xml2json", result);
				result.id = "1";

				let tree = {
					title: "",
					children: [result, { title: "", children: [] }]
				};

				set_store_value(stats, $stats = statsApi.generateStats(tree), $stats);
				set_store_value(bookmarks, $bookmarks = tree, $bookmarks);
			};

			reader.readAsText(file);
		} else {
			alert("File not supported, .txt or .json files only");
		}
	}

	return [files, handleFilesSelect];
}

class BookmarkFile extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default BookmarkFile;