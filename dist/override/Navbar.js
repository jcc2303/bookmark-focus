/* src/override/Navbar.svelte generated by Svelte v3.31.1 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import BookmarkFilter from "../routes/bookmarks/BookmarkFilter.js";
import { RotateCwIcon, CpuIcon } from "../../web_modules/svelte-feather-icons.js";
import { createEventDispatcher } from "../../web_modules/svelte.js";
import Theme from "../routes/Theme.js";
import Focused from "../routes/folders/Focused.js";
import chromeApi from "../background/chrome-api.js";
import Usetfjs from "../routes/bookmarks/Usetfjs.js";
import { filter, overview, stats } from "../stores.js";

function create_fragment(ctx) {
	let div3;
	let nav;
	let div2;
	let span;
	let button;
	let rotatecwicon;
	let t0;
	let div0;
	let focused;
	let updating_refresh;
	let t1;
	let div1;
	let bookmarkfilter;
	let t2;
	let theme;
	let current;
	let mounted;
	let dispose;
	rotatecwicon = new RotateCwIcon({ props: { size: "1x" } });

	function focused_refresh_binding(value) {
		/*focused_refresh_binding*/ ctx[5].call(null, value);
	}

	let focused_props = {};

	if (/*refresh*/ ctx[0] !== void 0) {
		focused_props.refresh = /*refresh*/ ctx[0];
	}

	focused = new Focused({ props: focused_props });
	binding_callbacks.push(() => bind(focused, "refresh", focused_refresh_binding));
	bookmarkfilter = new BookmarkFilter({});
	theme = new Theme({});

	return {
		c() {
			div3 = element("div");
			nav = element("nav");
			div2 = element("div");
			span = element("span");
			button = element("button");
			create_component(rotatecwicon.$$.fragment);
			t0 = space();
			div0 = element("div");
			create_component(focused.$$.fragment);
			t1 = space();
			div1 = element("div");
			create_component(bookmarkfilter.$$.fragment);
			t2 = space();
			create_component(theme.$$.fragment);
			attr(span, "class", "flex items-center");
			attr(div0, "class", "flex justify-between");
			attr(div1, "class", "px-8 w-full");
			attr(div2, "class", "flex flex-row justify-between");
			attr(nav, "class", "flex-row ");
			attr(div3, "class", "bg-purple-300 w-full p-1");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, nav);
			append(nav, div2);
			append(div2, span);
			append(span, button);
			mount_component(rotatecwicon, button, null);
			append(div2, t0);
			append(div2, div0);
			mount_component(focused, div0, null);
			append(div2, t1);
			append(div2, div1);
			mount_component(bookmarkfilter, div1, null);
			append(div2, t2);
			mount_component(theme, div2, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[4]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const focused_changes = {};

			if (!updating_refresh && dirty & /*refresh*/ 1) {
				updating_refresh = true;
				focused_changes.refresh = /*refresh*/ ctx[0];
				add_flush_callback(() => updating_refresh = false);
			}

			focused.$set(focused_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rotatecwicon.$$.fragment, local);
			transition_in(focused.$$.fragment, local);
			transition_in(bookmarkfilter.$$.fragment, local);
			transition_in(theme.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rotatecwicon.$$.fragment, local);
			transition_out(focused.$$.fragment, local);
			transition_out(bookmarkfilter.$$.fragment, local);
			transition_out(theme.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			destroy_component(rotatecwicon);
			destroy_component(focused);
			destroy_component(bookmarkfilter);
			destroy_component(theme);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $overview;
	let $stats;
	component_subscribe($$self, overview, $$value => $$invalidate(2, $overview = $$value));
	component_subscribe($$self, stats, $$value => $$invalidate(3, $stats = $$value));
	const dispatch = createEventDispatcher();
	let refresh;
	let folder;
	let cache;
	let data = [];

	const getBookmark = async (currentTab = {}) => {
		let searchResult = await chromeApi.bookmarks.search({ url: currentTab.url });
		return searchResult && searchResult[0];
	};

	async function doAnalisys() {
		let tabs = await chromeApi.tabs.query({ active: false });
		tabs = await Promise.all(tabs.map(t => getBookmark(t).then(b => b || t)));
		console.log(tabs);
		let recent = await chromeApi.bookmarks.getRecent(10) || [];
		data = [...tabs, ...recent.filter(l => l.parentId == "2")];
	}

	const click_handler = () => dispatch("refresh");

	function focused_refresh_binding(value) {
		refresh = value;
		$$invalidate(0, refresh);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$overview*/ 4) {
			$: folder = $overview;
		}

		if ($$self.$$.dirty & /*$stats*/ 8) {
			$: cache = $stats.cache;
		}
	};

	return [refresh, dispatch, $overview, $stats, click_handler, focused_refresh_binding];
}

class Navbar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Navbar;