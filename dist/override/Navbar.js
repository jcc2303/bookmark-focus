/* src/override/Navbar.svelte generated by Svelte v3.31.1 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import BookmarkFilter from "../routes/bookmarks/BookmarkFilter.js";
import { RotateCwIcon, CpuIcon } from "../../web_modules/svelte-feather-icons.js";
import { createEventDispatcher } from "../../web_modules/svelte.js";
import Theme from "../routes/Theme.js";
import Focused from "../routes/folders/Focused.js";
import chromeApi from "../background/chrome-api.js";
import Usetfjs from "../routes/bookmarks/Usetfjs.js";
import { filter, overview, stats } from "../stores.js";

function create_if_block(ctx) {
	let button;
	let cpuicon;
	let t;
	let usetfjs;
	let updating_data;
	let current;
	let mounted;
	let dispose;
	cpuicon = new CpuIcon({ props: { size: "1x" } });

	function usetfjs_data_binding(value) {
		/*usetfjs_data_binding*/ ctx[10].call(null, value);
	}

	let usetfjs_props = {
		cache: /*cache*/ ctx[2],
		overview: /*folder*/ ctx[1]
	};

	if (/*data*/ ctx[3] !== void 0) {
		usetfjs_props.data = /*data*/ ctx[3];
	}

	usetfjs = new Usetfjs({ props: usetfjs_props });
	binding_callbacks.push(() => bind(usetfjs, "data", usetfjs_data_binding));

	return {
		c() {
			button = element("button");
			create_component(cpuicon.$$.fragment);
			t = space();
			create_component(usetfjs.$$.fragment);
			attr(button, "class", "px-1");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			mount_component(cpuicon, button, null);
			insert(target, t, anchor);
			mount_component(usetfjs, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*doAnalisys*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const usetfjs_changes = {};
			if (dirty & /*cache*/ 4) usetfjs_changes.cache = /*cache*/ ctx[2];
			if (dirty & /*folder*/ 2) usetfjs_changes.overview = /*folder*/ ctx[1];

			if (!updating_data && dirty & /*data*/ 8) {
				updating_data = true;
				usetfjs_changes.data = /*data*/ ctx[3];
				add_flush_callback(() => updating_data = false);
			}

			usetfjs.$set(usetfjs_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cpuicon.$$.fragment, local);
			transition_in(usetfjs.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cpuicon.$$.fragment, local);
			transition_out(usetfjs.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			destroy_component(cpuicon);
			if (detaching) detach(t);
			destroy_component(usetfjs, detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div4;
	let nav;
	let div3;
	let span;
	let button;
	let rotatecwicon;
	let t0;
	let div0;
	let focused;
	let updating_refresh;
	let t1;
	let div1;
	let bookmarkfilter;
	let t2;
	let theme;
	let t3;
	let div2;
	let current;
	let mounted;
	let dispose;
	rotatecwicon = new RotateCwIcon({ props: { size: "1x" } });

	function focused_refresh_binding(value) {
		/*focused_refresh_binding*/ ctx[9].call(null, value);
	}

	let focused_props = {};

	if (/*refresh*/ ctx[0] !== void 0) {
		focused_props.refresh = /*refresh*/ ctx[0];
	}

	focused = new Focused({ props: focused_props });
	binding_callbacks.push(() => bind(focused, "refresh", focused_refresh_binding));
	bookmarkfilter = new BookmarkFilter({});
	theme = new Theme({});
	let if_block = /*cache*/ ctx[2] && /*folder*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			div4 = element("div");
			nav = element("nav");
			div3 = element("div");
			span = element("span");
			button = element("button");
			create_component(rotatecwicon.$$.fragment);
			t0 = space();
			div0 = element("div");
			create_component(focused.$$.fragment);
			t1 = space();
			div1 = element("div");
			create_component(bookmarkfilter.$$.fragment);
			t2 = space();
			create_component(theme.$$.fragment);
			t3 = space();
			div2 = element("div");
			if (if_block) if_block.c();
			attr(span, "class", "flex items-center");
			attr(div0, "class", "flex justify-between");
			attr(div1, "class", "px-8 w-full");
			attr(div2, "class", "flex w-40 justify-end items-center content-center h-full border");
			attr(div3, "class", "flex flex-row justify-between");
			attr(nav, "class", "flex-row ");
			attr(div4, "class", "bg-purple-300 w-full p-1");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, nav);
			append(nav, div3);
			append(div3, span);
			append(span, button);
			mount_component(rotatecwicon, button, null);
			append(div3, t0);
			append(div3, div0);
			mount_component(focused, div0, null);
			append(div3, t1);
			append(div3, div1);
			mount_component(bookmarkfilter, div1, null);
			append(div3, t2);
			mount_component(theme, div3, null);
			append(div3, t3);
			append(div3, div2);
			if (if_block) if_block.m(div2, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const focused_changes = {};

			if (!updating_refresh && dirty & /*refresh*/ 1) {
				updating_refresh = true;
				focused_changes.refresh = /*refresh*/ ctx[0];
				add_flush_callback(() => updating_refresh = false);
			}

			focused.$set(focused_changes);

			if (/*cache*/ ctx[2] && /*folder*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*cache, folder*/ 6) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div2, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(rotatecwicon.$$.fragment, local);
			transition_in(focused.$$.fragment, local);
			transition_in(bookmarkfilter.$$.fragment, local);
			transition_in(theme.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(rotatecwicon.$$.fragment, local);
			transition_out(focused.$$.fragment, local);
			transition_out(bookmarkfilter.$$.fragment, local);
			transition_out(theme.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_component(rotatecwicon);
			destroy_component(focused);
			destroy_component(bookmarkfilter);
			destroy_component(theme);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $overview;
	let $stats;
	component_subscribe($$self, overview, $$value => $$invalidate(6, $overview = $$value));
	component_subscribe($$self, stats, $$value => $$invalidate(7, $stats = $$value));
	const dispatch = createEventDispatcher();
	let refresh;
	let folder;
	let cache;
	let data = [];

	const getBookmark = async (currentTab = {}) => {
		let searchResult = await chromeApi.bookmarks.search({ url: currentTab.url });
		return searchResult && searchResult[0];
	};

	async function doAnalisys() {
		let tabs = await chromeApi.tabs.query({ active: false });
		tabs = await Promise.all(tabs.map(t => getBookmark(t).then(b => b || t)));
		console.log(tabs);
		let recent = await chromeApi.bookmarks.getRecent(10) || [];
		$$invalidate(3, data = [...tabs, ...recent.filter(l => l.parentId == "2")]);
	}

	const click_handler = () => dispatch("refresh");

	function focused_refresh_binding(value) {
		refresh = value;
		$$invalidate(0, refresh);
	}

	function usetfjs_data_binding(value) {
		data = value;
		$$invalidate(3, data);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$overview*/ 64) {
			$: $$invalidate(1, folder = $overview);
		}

		if ($$self.$$.dirty & /*$stats*/ 128) {
			$: $$invalidate(2, cache = $stats.cache);
		}
	};

	return [
		refresh,
		folder,
		cache,
		data,
		dispatch,
		doAnalisys,
		$overview,
		$stats,
		click_handler,
		focused_refresh_binding,
		usetfjs_data_binding
	];
}

class Navbar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Navbar;