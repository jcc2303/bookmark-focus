import { S as SvelteComponent, i as init, s as safe_not_equal, b as svg_element, d as attr, e as insert, f as append, n as noop, g as detach } from './common/index-c896576c.js';

/* node_modules/svelte-feather-icons/src/icons/ActivityIcon.svelte generated by Svelte v3.31.1 */

function create_fragment(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr(polyline, "points", "22 12 18 12 15 21 9 3 6 12 2 12");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-activity " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-activity " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class ActivityIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/ArrowLeftIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$1(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr(line, "x1", "19");
			attr(line, "y1", "12");
			attr(line, "x2", "5");
			attr(line, "y2", "12");
			attr(polyline, "points", "12 19 5 12 12 5");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-arrow-left " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, line);
			append(svg, polyline);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-arrow-left " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class ArrowLeftIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/AwardIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$2(ctx) {
	let svg;
	let circle;
	let polyline;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			attr(circle, "cx", "12");
			attr(circle, "cy", "8");
			attr(circle, "r", "7");
			attr(polyline, "points", "8.21 13.89 7 23 12 20 17 23 15.79 13.88");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-award " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, polyline);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-award " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class AwardIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/BookIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$3(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M4 19.5A2.5 2.5 0 0 1 6.5 17H20");
			attr(path1, "d", "M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-book " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-book " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class BookIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/BookmarkIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$4(ctx) {
	let svg;
	let path;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-bookmark " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-bookmark " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class BookmarkIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/ChevronLeftIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$5(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr(polyline, "points", "15 18 9 12 15 6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-chevron-left " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-chevron-left " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class ChevronLeftIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/CpuIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$6(ctx) {
	let svg;
	let rect0;
	let rect1;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			attr(rect0, "x", "4");
			attr(rect0, "y", "4");
			attr(rect0, "width", "16");
			attr(rect0, "height", "16");
			attr(rect0, "rx", "2");
			attr(rect0, "ry", "2");
			attr(rect1, "x", "9");
			attr(rect1, "y", "9");
			attr(rect1, "width", "6");
			attr(rect1, "height", "6");
			attr(line0, "x1", "9");
			attr(line0, "y1", "1");
			attr(line0, "x2", "9");
			attr(line0, "y2", "4");
			attr(line1, "x1", "15");
			attr(line1, "y1", "1");
			attr(line1, "x2", "15");
			attr(line1, "y2", "4");
			attr(line2, "x1", "9");
			attr(line2, "y1", "20");
			attr(line2, "x2", "9");
			attr(line2, "y2", "23");
			attr(line3, "x1", "15");
			attr(line3, "y1", "20");
			attr(line3, "x2", "15");
			attr(line3, "y2", "23");
			attr(line4, "x1", "20");
			attr(line4, "y1", "9");
			attr(line4, "x2", "23");
			attr(line4, "y2", "9");
			attr(line5, "x1", "20");
			attr(line5, "y1", "14");
			attr(line5, "x2", "23");
			attr(line5, "y2", "14");
			attr(line6, "x1", "1");
			attr(line6, "y1", "9");
			attr(line6, "x2", "4");
			attr(line6, "y2", "9");
			attr(line7, "x1", "1");
			attr(line7, "y1", "14");
			attr(line7, "x2", "4");
			attr(line7, "y2", "14");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-cpu " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, line0);
			append(svg, line1);
			append(svg, line2);
			append(svg, line3);
			append(svg, line4);
			append(svg, line5);
			append(svg, line6);
			append(svg, line7);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-cpu " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class CpuIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/CrosshairIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$7(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "10");
			attr(line0, "x1", "22");
			attr(line0, "y1", "12");
			attr(line0, "x2", "18");
			attr(line0, "y2", "12");
			attr(line1, "x1", "6");
			attr(line1, "y1", "12");
			attr(line1, "x2", "2");
			attr(line1, "y2", "12");
			attr(line2, "x1", "12");
			attr(line2, "y1", "6");
			attr(line2, "x2", "12");
			attr(line2, "y2", "2");
			attr(line3, "x1", "12");
			attr(line3, "y1", "22");
			attr(line3, "x2", "12");
			attr(line3, "y2", "18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-crosshair " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, line0);
			append(svg, line1);
			append(svg, line2);
			append(svg, line3);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-crosshair " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class CrosshairIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/EditIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$8(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
			attr(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-edit " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-edit " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class EditIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/ExternalLinkIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$9(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr(path, "d", "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6");
			attr(polyline, "points", "15 3 21 3 21 9");
			attr(line, "x1", "10");
			attr(line, "y1", "14");
			attr(line, "x2", "21");
			attr(line, "y2", "3");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-external-link " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, polyline);
			append(svg, line);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-external-link " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class ExternalLinkIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/EyeIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$a(ctx) {
	let svg;
	let path;
	let circle;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr(path, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "3");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-eye " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-eye " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class EyeIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/FilterIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$b(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr(polygon, "points", "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-filter " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polygon);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-filter " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class FilterIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/FolderMinusIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$c(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			attr(line, "x1", "9");
			attr(line, "y1", "14");
			attr(line, "x2", "15");
			attr(line, "y2", "14");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-folder-minus " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, line);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-folder-minus " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class FolderMinusIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/FolderPlusIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$d(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			attr(line0, "x1", "12");
			attr(line0, "y1", "11");
			attr(line0, "x2", "12");
			attr(line0, "y2", "17");
			attr(line1, "x1", "9");
			attr(line1, "y1", "14");
			attr(line1, "x2", "15");
			attr(line1, "y2", "14");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-folder-plus " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, line0);
			append(svg, line1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-folder-plus " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class FolderPlusIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/FolderIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$e(ctx) {
	let svg;
	let path;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-folder " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-folder " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class FolderIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/HomeIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$f(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr(path, "d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z");
			attr(polyline, "points", "9 22 9 12 15 12 15 22");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-home " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, polyline);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-home " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class HomeIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/ImageIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$g(ctx) {
	let svg;
	let rect;
	let circle;
	let polyline;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			attr(rect, "x", "3");
			attr(rect, "y", "3");
			attr(rect, "width", "18");
			attr(rect, "height", "18");
			attr(rect, "rx", "2");
			attr(rect, "ry", "2");
			attr(circle, "cx", "8.5");
			attr(circle, "cy", "8.5");
			attr(circle, "r", "1.5");
			attr(polyline, "points", "21 15 16 10 5 21");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-image " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, circle);
			append(svg, polyline);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-image " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class ImageIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/LinkIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$h(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71");
			attr(path1, "d", "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-link " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-link " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class LinkIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/RotateCwIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$i(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr(polyline, "points", "23 4 23 10 17 10");
			attr(path, "d", "M20.49 15a9 9 0 1 1-2.12-9.36L23 10");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-rotate-cw " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-rotate-cw " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class RotateCwIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/SearchIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$j(ctx) {
	let svg;
	let circle;
	let line;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			attr(circle, "cx", "11");
			attr(circle, "cy", "11");
			attr(circle, "r", "8");
			attr(line, "x1", "21");
			attr(line, "y1", "21");
			attr(line, "x2", "16.65");
			attr(line, "y2", "16.65");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-search " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, line);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-search " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class SearchIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/ShuffleIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$k(ctx) {
	let svg;
	let polyline0;
	let line0;
	let polyline1;
	let line1;
	let line2;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			line0 = svg_element("line");
			polyline1 = svg_element("polyline");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr(polyline0, "points", "16 3 21 3 21 8");
			attr(line0, "x1", "4");
			attr(line0, "y1", "20");
			attr(line0, "x2", "21");
			attr(line0, "y2", "3");
			attr(polyline1, "points", "21 16 21 21 16 21");
			attr(line1, "x1", "15");
			attr(line1, "y1", "15");
			attr(line1, "x2", "21");
			attr(line1, "y2", "21");
			attr(line2, "x1", "4");
			attr(line2, "y1", "4");
			attr(line2, "x2", "9");
			attr(line2, "y2", "9");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-shuffle " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline0);
			append(svg, line0);
			append(svg, polyline1);
			append(svg, line1);
			append(svg, line2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-shuffle " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class ShuffleIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/StarIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$l(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr(polygon, "points", "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-star " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polygon);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-star " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class StarIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/TargetIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$m(ctx) {
	let svg;
	let circle0;
	let circle1;
	let circle2;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr(circle0, "cx", "12");
			attr(circle0, "cy", "12");
			attr(circle0, "r", "10");
			attr(circle1, "cx", "12");
			attr(circle1, "cy", "12");
			attr(circle1, "r", "6");
			attr(circle2, "cx", "12");
			attr(circle2, "cy", "12");
			attr(circle2, "r", "2");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-target " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-target " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class TargetIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$m, create_fragment$m, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/Trash2Icon.svelte generated by Svelte v3.31.1 */

function create_fragment$n(ctx) {
	let svg;
	let polyline;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(polyline, "points", "3 6 5 6 21 6");
			attr(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
			attr(line0, "x1", "10");
			attr(line0, "y1", "11");
			attr(line0, "x2", "10");
			attr(line0, "y2", "17");
			attr(line1, "x1", "14");
			attr(line1, "y1", "11");
			attr(line1, "x2", "14");
			attr(line1, "y2", "17");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-trash-2 " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
			append(svg, path);
			append(svg, line0);
			append(svg, line1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-trash-2 " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class Trash2Icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/TypeIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$o(ctx) {
	let svg;
	let polyline;
	let line0;
	let line1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(polyline, "points", "4 7 4 4 20 4 20 7");
			attr(line0, "x1", "9");
			attr(line0, "y1", "20");
			attr(line0, "x2", "15");
			attr(line0, "y2", "20");
			attr(line1, "x1", "12");
			attr(line1, "y1", "4");
			attr(line1, "x2", "12");
			attr(line1, "y2", "20");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-type " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
			append(svg, line0);
			append(svg, line1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-type " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class TypeIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$o, create_fragment$o, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

/* node_modules/svelte-feather-icons/src/icons/XSquareIcon.svelte generated by Svelte v3.31.1 */

function create_fragment$p(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let svg_class_value;

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(rect, "x", "3");
			attr(rect, "y", "3");
			attr(rect, "width", "18");
			attr(rect, "height", "18");
			attr(rect, "rx", "2");
			attr(rect, "ry", "2");
			attr(line0, "x1", "9");
			attr(line0, "y1", "9");
			attr(line0, "x2", "15");
			attr(line0, "y2", "15");
			attr(line1, "x1", "15");
			attr(line1, "y1", "9");
			attr(line1, "x2", "9");
			attr(line1, "y2", "15");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", svg_class_value = "feather feather-x-square " + /*customClass*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, line0);
			append(svg, line1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-x-square " + /*customClass*/ ctx[2])) {
				attr(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	return [size, strokeWidth, customClass];
}

class XSquareIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$p, create_fragment$p, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
	}
}

export { ActivityIcon, ArrowLeftIcon, AwardIcon, BookIcon, BookmarkIcon, ChevronLeftIcon, CpuIcon, CrosshairIcon, EditIcon, ExternalLinkIcon, EyeIcon, FilterIcon, FolderIcon, FolderMinusIcon, FolderPlusIcon, HomeIcon, ImageIcon, LinkIcon, RotateCwIcon, SearchIcon, ShuffleIcon, StarIcon, TargetIcon, Trash2Icon, TypeIcon, XSquareIcon };
